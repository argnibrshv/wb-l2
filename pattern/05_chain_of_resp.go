package pattern

// Цепочка вызовов (Chain of responsibility) - поведенческий шаблон проектирования, который позволяет избежать
// жесткой привязки отправителя запроса к получателю. Все возможные обработчики запроса образуют цепочку,
// а сам запрос перемещается по этой цепочке. Каждый объект в этой цепочке при получении запроса выбирает,
// либо закончить обработку запроса, либо передать запрос на обработку следующему по цепочке объекту.

// Паттерн цепочка вызовов применяется:
// Когда имеется более одного объекта, который может обработать определенный запрос.
// Когда надо передать запрос на выполнение одному из нескольких объект, точно не определяя, какому именно объекту.
// Когда набор объектов задается динамически.

// Преимущества паттерна цепочка вызовов:
// Ослабление связанности между объектами. Отправителю и получателю запроса ничего не известно друг о друге.
// Клиенту неизветна цепочка объектов, какие именно объекты составляют ее, как запрос в ней передается.
// В цепочку с легкостью можно добавлять новые типы объектов, которые реализуют общий интерфейс.

// Недостатки паттерна цепочка вызовов:
// никто не гарантирует, что запрос в конечном счете будет обработан. Если необходимого обработчика в цепочки
// не оказалось, то запрос просто выходит из цепочки и остается необработанным.

// Интерфейс обработчика
type Handler interface {
	SendRequest(message int) string
}

// Конкретный обработчик/
type ConcreteHandlerA struct {
	next Handler
}

func (h *ConcreteHandlerA) SendRequest(message int) (result string) {
	if message == 1 {
		result = "Im handler 1"
	} else if h.next != nil {
		result = h.next.SendRequest(message)
	}
	return
}

// Конкретный обработчик.
type ConcreteHandlerB struct {
	next Handler
}

func (h *ConcreteHandlerB) SendRequest(message int) (result string) {
	if message == 2 {
		result = "Im handler 2"
	} else if h.next != nil {
		result = h.next.SendRequest(message)
	}
	return
}
